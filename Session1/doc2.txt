
- Test Driven Development
    - Write Failing Test First
        - Write a failing test. 
        - Developers start by writing a test that defines the behavior they want to implement but for which there is currently no code. 
        - This initial test should fail because the functionality being tested hasn't been implemented yet.

    - Write code to pass the failing test
        - Write the simplest code to pass the test. 
        - Developers write the minimum amount of code required to make the failing test pass. 
        - The focus here is solely on making the test pass, without worrying about code quality or optimization.

    - Refactor code or remove duplicate code.
        - Improve the code while keeping tests passing. 
        - Once the test passes, developers refactor the code to improve its design, readability, and efficiency while ensuring that all tests continue to pass. 
        - Refactoring helps maintain a clean codebase and ensures that the code remains easy to maintain and extend.


- Rules For TDD
    - You must write a failing test before you write any production code. This ensures that tests are written to validate actual requirements rather than just verifying existing behavior.
    - You must write just enough production code to make the failing test pass. This encourages developers to write only the code necessary to fulfill the requirements, preventing over-engineering and keeping the codebase lean.
    - You must write only enough test code to fail. This emphasizes writing focused, granular tests that target specific behaviors or functionalities, rather than writing overly complex or redundant tests.


- Why Failing Test Cases
    - Clarifying requirements
        - Writing a failing test case forces developers to think about the behavior they want to implement before they write any code. 
        - This helps clarify the requirements and ensures that the developers have a clear understanding of what needs to be implemented.

    - validation of test
        - By writing failing test cases first, developers can ensure that their tests are effective in identifying when the desired functionality is not yet implemented.

    - Incremental development
        - Starting with a failing test encourages developers to implement the functionality incrementally, 
        - focusing on small manageable units of work. 
        - This iterative approach helps break down larger tasks into smaller, more manageable steps, making the development process more manageable and reducing the risk of introducing bugs.

    - focus on Behaviour
        - Failing test cases describe the desired behavior of the system from the perspective of the user or client. 
        - By focusing on failing tests, developers prioritize implementing features that provide value to the end-users and align with the project's requirements.
                
    - Reduces Bias
        - Writing failing test cases first helps reduce confirmation bias, where developers might unintentionally write code that confirms their assumptions rather than implementing the actual requirements. 
        - By starting with a failing test, developers are forced to confront the reality of what needs to be implemented, rather than what they believe should be implemented.


